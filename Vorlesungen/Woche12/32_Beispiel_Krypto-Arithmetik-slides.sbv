0:00:00.880,0:00:08.790
Also betrachten wir ein weiteres Beispiel
für Generate-and-Test. Und zwar soll das

0:00:08.790,0:00:16.490
so ein kleines arithmetisches Puzzle sein.
Kryptologisch im Sinne, dass irgendetwas

0:00:16.490,0:00:22.239
codiert ist und wir erst mal herausfinden
müssen und hoffentlich können, welche Buchstaben

0:00:22.239,0:00:28.829
für welche (in dem Fall) Ziffern stehen.
Diese Art Rätsel kennen Sie sicherlich.

0:00:28.829,0:00:33.950
Dieses Beispiel konkret kommt tatsächlich aus
dem Wikipedia-Eintrag zu Prolog. Da könnten Sie

0:00:33.950,0:00:41.990
das also auch so ähnlich nachlesen, wie ich
das jetzt hier mache. Der Punkt ist: Wir haben

0:00:41.990,0:00:49.340
hier mehrere solcher Rechnungen skizziert. Da kommen
Buchstaben drin vor. Die sollen für Ziffern stehen.

0:00:49.340,0:00:53.980
Und zwar jeder Buchstabe für eine andere Ziffer.
Also A und B können nicht durch die gleiche Ziffer

0:00:53.980,0:01:00.280
ersetzt werden. Und natürlich soll das, was
hier jeweils sowohl in den Zeilen als auch in

0:01:00.280,0:01:05.719
den Spalten als Gleichungen steht,
erfüllt sein für eine passende Belegung.

0:01:05.719,0:01:10.550
Und eigentlich kommt am Ende auch noch ein Ergebnis
heraus. Das interessiert uns gar nicht so sehr.

0:01:10.550,0:01:17.799
Uns interessiert eine passende Belegung. Und
zwar derart, dass hier und hier der gleiche

0:01:17.799,0:01:22.941
Wert herauskommt. Welcher das konkret ist, das kann am Ende
einfach ausgerechnet werden. Aber der Punkt ist, dass die Belegungen

0:01:22.941,0:01:26.439
natürlich dadurch eingeschränkt sind, dass überhaupt
erst mal alle anderen Gleichungen auch gelten müssen

0:01:26.439,0:01:36.609
und die Gleichheit dieser beiden Rechnungen. Wie
können wir jetzt zu so einer gültigen Belegung kommen?

0:01:36.609,0:01:44.350
Wir sind im Generate-and-Test-Teil.
Das besprechen wir gerade.

0:01:44.350,0:01:51.810
Also vielleicht ist es naheliegend, eine
Generate-and-Test Lösung zu versuchen. Also was wären

0:01:51.810,0:01:58.179
hier unsere Antworten, die wir haben wollen? Wir wollen
Belegungen/Werte für A, B, C, D, E, F, G, H haben.

0:01:58.179,0:02:04.939
Eine Solution/ eine Lösung wird aus diesen
acht Werten bestehen. Also sollten wir die

0:02:04.939,0:02:09.720
einerseits generieren. Also beschreiben, aus welchen
Suchraum denn überhaupt diese Lösungen kommen können.

0:02:09.720,0:02:15.750
Dann müssen wir die Bedingungen ausdrücken
in dem Test, dass tatsächlich eine solche

0:02:15.750,0:02:23.210
Belegung von Ziffern für A, B, C bis H
auch wirklich gültig und gewünscht ist.

0:02:23.210,0:02:31.930
Dann könnten wir zu einer konkreten Lösung
kommen. Wie sollte jetzt das Generieren aussehen?

0:02:31.930,0:02:37.160
Was heißt hier das Generieren? Nun, hier entspricht vor
allem diese erste Zeile sozusagen dem Generate-Teil.

0:02:37.160,0:02:44.560
Und dann die Gültigkeit, also die Erfüllung
all dieser Gleichungen wäre der Test-Teil.

0:02:44.560,0:02:49.910
Also was ist der Generate-Teil? Der sagt: Jeder
Buchstabe entspräche einer Ziffer, und zwar einer

0:02:49.910,0:02:56.020
anderen Ziffer. Wir suchen also Zuordnungen von den
Buchstaben/ von den Werten A bis H zu einzelnen Ziffern.

0:02:56.020,0:03:03.480
Also letztlich Zahlen von 0 bis 9. Und zwar derart, dass
verschiedene Buchstaben auch verschiedene Ziffern haben.

0:03:03.480,0:03:10.090
So etwas haben wir jetzt ja schon mehrfach
gesehen. Auch in dem Würfelbeispiel.

0:03:10.090,0:03:14.460
Wie kann ich solch eine Auswahl und
gleichzeitig Verschiedenheit ausdrücken?

0:03:14.460,0:03:22.870
Durch Verwendung des Permutationsprädikats. Also
ich könnte sagen: Diese A bis H, das seien Werte,

0:03:22.870,0:03:28.960
einer Permutation dieser Liste aller infrage kommenden Ziffern
entnommen werden. Und wie in dem anderen Beispiel auch

0:03:28.960,0:03:32.790
ist es wieder so, da das ja zehn Ziffern sind,
muss ich hier in der Permutation natürlich auch

0:03:32.790,0:03:37.630
zehn Plätze vorsehen, von denen mich aber zwei
nicht interessieren sollen, da ich tatsächlich

0:03:37.630,0:03:41.570
nur acht Buchstaben zu belegen habe. Also wir haben zehn
Ziffern, aber im Rätsel kommen nur acht Buchstaben vor.

0:03:41.570,0:03:46.720
Das heißt, zwei Ziffern werden ungenutzt bleiben. Das
ungenutzt bleiben kann ich wieder mit dieser anonymen

0:03:46.720,0:03:53.040
Variable ausdrücken, wo ich sage: Die letzten beiden
Plätze interessieren mich nicht. Damit hätte ich bereits

0:03:53.040,0:03:59.710
den Generierungs-Teil ausgedrückt. Das ist oftmals
der einfachere Teil beim Generate-and-Test.

0:03:59.710,0:04:10.180
So auch hier. Wie sieht dann der Test-Teil aus?
Also wie drücke ich denn aus, dass eine solche

0:04:10.180,0:04:14.160
Belegung, die hier generiert wurde (das können ja
sehr viele verschiedene sein), dass die gültig ist?

0:04:14.160,0:04:19.630
Also jetzt die Frage, wie ich dieses Test-Prädikat
schreibe, was ich hier an Bedingungen habe. Und natürlich

0:04:19.630,0:04:26.010
muss ich da das haben, was in meinem Rätsel
vorkommt. Das sind mehrere Bedingungen.

0:04:26.010,0:04:34.540
Letztlich würde jede Zeile und jede Spalte irgendwie in
dieses Test-Prädikat eingehen müssen, denn genau diese

0:04:34.540,0:04:40.200
Rechnungen, die hier symbolisch stehen, das sind die Bedingungen,
die wirklich die Gültigkeit einer Belegung ausmachen.

0:04:40.200,0:04:52.720
Also wie wäre es zum Beispiel mit der
ersten Zeile? Die sagt: ABB - CD = EED.

0:04:52.720,0:04:57.630
Das heißt, da müssen wir rechnen. Wenn wir eine
Belegung für A, B, C etc. hätten, könnten wir

0:04:57.630,0:05:04.740
ja den Wert ABB bilden. Durch letztlich im
Stellensystem die Ziffer A × 100 + B × 10 + B × 1.

0:05:04.740,0:05:10.790
Und das Gleiche könnten wir
für diese beiden Zahlen jeweils

0:05:10.790,0:05:15.880
aus ihrer Zifferndarstellung erreichen.
Dann müssten wir einfach überprüfen, ob

0:05:15.880,0:05:20.120
denn tatsächlich diese Gleichheit gilt. Also
den linken Teil ausrechnen. Die rechte Zahl

0:05:20.120,0:05:23.960
ausrechnen und schauen, ob die gleich sind. Das
sind alles Sachen, die wir schon gesehen haben, wie

0:05:23.960,0:05:32.410
wir das in Prolog tun können. Die erste Zeile könnte
dieser Bedingung entsprechen. Im Test haben wir jetzt

0:05:32.410,0:05:36.990
angenommen, dass wir irgendwelche Ziffern für A, B, C
etc. gewählt haben. Also können wir die nehmen und daraus

0:05:36.990,0:05:42.370
die Zahlen bilden. Das wäre die erste Zahl ABB.
Das wäre die zweite Zahl CD und das ist das,

0:05:42.370,0:05:49.100
was in der ersten Zeile als Ergebnis steht EED.
Und wir fordern, dass diese Zahl minus diese Zahl

0:05:49.100,0:05:59.540
arithmetisch gleich dieser Zahl sein soll.
Das ist eine sehr direkte Übersetzung

0:05:59.540,0:06:05.050
dieser ersten Zeile. Genauso können wir vorgehen für die
Spalten etwa. Wenn wir uns die erste Spalte anschauen,

0:06:05.050,0:06:09.740
so runterwärts gelesen. Dann würden
wir für ABB wieder vorgehen wie eben.

0:06:09.740,0:06:16.419
FD wäre F × 10 + D × 1 und EGD können wir auch
zusammenbasteln aus den Ziffereinträgen für EGD.

0:06:16.419,0:06:22.930
Und dann fordern wir eben, dass diese Subtraktion
gültig sein muss. Das heißt, wir erhalten für die

0:06:22.930,0:06:30.240
erste Spalte diese Bedingung. Erste Zeile. Erste Spalte.
Das Nächste wäre dann zum Beispiel, zweite Zeile

0:06:30.240,0:06:41.430
und zweite Spalte umzusetzen. Das geht so: (Das können
Sie in der Darstellung hier wieder nachschlagen.)

0:06:41.430,0:06:47.150
Das ist sogar etwas kürzer, weil jetzt in zweiter
Zeile und zweiter Spalte keine dreistelligen

0:06:47.150,0:06:52.060
Zahlen vorkommen. Deswegen ist der Zusammenbau der
Zahlen aus den Ziffern etwas einfacher/ etwas kürzer.

0:06:52.060,0:07:01.070
Deswegen passt da auch jeweils jede Bedingung in eine
Zeile. Anders als in diesen beiden Bedingungen hier.

0:07:01.070,0:07:05.790
Deswegen ist das etwas kürzer hier, aber
entspricht genau dem gleichen Schema.

0:07:05.790,0:07:12.871
Dann müssen wir uns noch um die letzte Zeile
und letzte Spalte kümmern. Für die ist es so,

0:07:12.871,0:07:18.979
dass da dieses Fragezeichen steht. Wir können also
nicht sagen: "Die Zahl gebaut * die Zahl gebaut ist

0:07:18.979,0:07:24.770
irgendwie eine ganz konkrete Zahl." So wie es
in den anderen Zeilen und Spalten der Fall war.

0:07:24.770,0:07:31.930
Nun, die Bedingung hier ist einfach, dass bei
dieser Multiplikation und dieser Multiplikation

0:07:31.930,0:07:37.479
das Gleiche herauszukommen hat. Irgendetwas, aber
das Gleiche. Wir haben keine konkrete Vorgabe dafür,

0:07:37.479,0:07:44.470
dass das irgendwie ABEHG oder so sein
soll. Aber natürlich können wir auch diese

0:07:44.470,0:07:49.130
Gleichheit von diesen beiden Multiplikationen in Prolog
ausdrücken. Auf ähnliche Weise, wie wir die anderen

0:07:49.130,0:07:53.600
Zeilen und Spalten ausgedrückt haben. Wir bilden
einfach die Zahlen aus den Ziffern. Multiplizieren

0:07:53.600,0:07:58.320
einmal das, was in der letzten Zeile steht.
Einmal das, was in der letzten Spalte steht.

0:07:58.320,0:08:04.010
Und fordern einfach, dass die Ergebnisse gleich sein müssen. Nicht
irgendwie gleich einer bestimmten Konstante, sondern einfach gleich.

0:08:04.010,0:08:13.501
Das können wir so ausdrücken. Wir bilden die eine Zahl,
die andere Zahl und fordern, dass sie gleich sind.

0:08:13.501,0:08:20.560
Damit entspricht dieser Test hier oder
diese Zeile/ dieser Teil des Tests genau

0:08:20.560,0:08:26.410
der Tatsache, dass hier das Gleiche herauskommen
muss in der letzten Zeile und letzten Spalte.

0:08:26.410,0:08:35.180
Damit sind wir fertig. Jetzt müssen wir nur noch die Sachen,
die wir gerade als Gleichungen hier aufgestellt haben,

0:08:35.180,0:08:42.380
zusammensammeln, und zwar im Test-Prädikat.
Das sind die gleichen Bedingungen,

0:08:42.380,0:08:47.920
die ich gerade schrittweise aufgestellt habe. Die
packe ich alle zusammen, durch Konjunktion verknüpft.

0:08:47.920,0:08:52.330
Wie in Prolog üblich, auf der rechten Seite durch Kommata
getrennt. Mehrere Bedingungen werden durch Konjunktion verknüpft.

0:08:52.330,0:08:56.210
Die müssen also alle zutreffen.
Und das sind Bedingungen an solch

0:08:56.210,0:09:05.130
einen Lösungskandidaten, der aus acht Ziffern für A bis H
besteht. Dann haben wir ein Prolog-Programm vervollständigt.

0:09:05.130,0:09:10.390
Jetzt können wir das Prolog einfach
übergeben und es lösen lassen.

0:09:10.390,0:09:18.649
Lösen lassen heißt in dem Fall natürlich: Aufruf
unseres solve-Prädikats, welches den Generations- und

0:09:18.649,0:09:26.279
den Test-Teil zusammenfügt. Dann müssten
wir eine Lösung für dieses Rätsel bekommen.

0:09:26.279,0:09:32.730
Rufen wir das auf. Und wir bekommen genau eine
Belegung. Es wäre denkbar gewesen, dass es vielleicht

0:09:32.730,0:09:35.970
mehrere Belegungen/ mehrere Wahlen gibt, aber
tatsächlich erhalten wir genau eine Belegung.

0:09:35.970,0:09:43.050
Nämlich diese hier. Prolog antwortet,
dass A = 2, B = 0, C = 8 etc. sein soll.

0:09:43.050,0:09:48.160
Prolog behauptet damit natürlich auch, dass es alle diese
Bedingungen erfüllt, sonst wäre das nicht die Antwort.

0:09:48.160,0:09:54.140
Dann können wir das noch in unser Schema
einsetzen und einfach schauen, wie denn die Lösung

0:09:54.140,0:09:59.910
dann konkret aussieht, wenn wir das aufschreiben.
Dann würden wir eben dieses Bild erhalten.

0:09:59.910,0:10:07.540
Das sind jetzt jeweils für A, B, C etc.
einfach die Ziffern eingesetzt aus dieser

0:10:07.540,0:10:13.110
Antwort von Prolog. Die Zahl hier unten ist einfach mal
ausgerechnet. Vielleicht einfach nur zum Test für uns noch mal,

0:10:13.110,0:10:17.610
dass wirklich der gleiche Wert herauskommt.
In dem Rätsel war es ja egal, was dort steht.

0:10:17.610,0:10:22.610
Es musste nur das Gleiche sein, dieses Fragezeichen. Wenn wir jetzt
konkrete Belegungen haben, können wir einfach ausrechnen, was da rauskommt.

0:10:22.610,0:10:26.550
Natürlich hat Prolog das bei der Suche auch schon getan, weil
das ja eine der Bedingungen war, zu prüfen, dass diese beiden

0:10:26.550,0:10:31.730
Multiplikationen das gleiche Ergebnis haben. In
dem konkreten Fall ist es eben das Ergebnis 9315.

0:10:31.730,0:10:36.790
Was wir auch sehen, ist, dass nicht alle Ziffern
benutzt wurden. Wenn wir hier draufschauen,

0:10:36.790,0:10:40.160
sehen wir, dass die Ziffern vier und sieben nicht genutzt
wurden. Das hätten wir natürlich auch schon hier gesehen.

0:10:40.160,0:10:46.350
Also diese Tatsache, dass wir zehn Ziffern
haben, aber nur acht Buchstaben, sorgt dafür,

0:10:46.350,0:10:49.589
dass zwei Ziffern nicht genutzt werden. In dem
konkreten Fall sind das eben die vier und die sieben,

0:10:49.589,0:10:54.990
die nicht gebraucht werden für diese Lösung. Was wir auch
sehen, ist, dass (glücklicherweise, könnte gesagt werden)

0:10:54.990,0:10:59.820
jetzt nicht irgendwie die Null für eine erste Ziffer
genommen wurde. Wir hätten uns auch Sorgen machen können,

0:10:59.820,0:11:05.980
wenn hier statt sechs die Null stünde, ob es
denn überhaupt noch eine sinnvolle Zahl ist: 05?

0:11:05.980,0:11:11.160
Nun ist es bei dieser Lösung so, dass die Null eben nie an erster
Stelle steht. Wir hätten natürlich auch in dem Generate-Teil

0:11:11.160,0:11:17.390
einfach fordern können, dass alles, was
in dem Rätsel jemals an erster Stelle

0:11:17.390,0:11:23.640
auftaucht, also A, C etc., die nicht null sein dürfen.
Dann hätten wir die Suche vielleicht etwas eingeschränkt.

0:11:23.640,0:11:31.870
Diesem Prädikat hätten wir einfach auch verbieten
können, dass zum Beispiel A = 0 sein darf.

0:11:31.870,0:11:38.120
Das haben wir nicht getan. War aber auch nicht
nötig. Insofern, als die entstehende Lösung

0:11:38.120,0:11:47.740
sowieso die Eigenschaft hat, dass nie eine Null
vorn steht. So hat uns Prolog geholfen, dieses

0:11:47.740,0:11:52.279
konkrete Rätsel zu lösen. Natürlich lassen
sich sehr viele ähnliche Rätsel auf analoge

0:11:52.279,0:11:58.370
Art und Weise lösen. Es muss einfach immer sinnvoll
beschrieben werden, was denn überhaupt generiert werden darf.

0:11:58.370,0:12:02.540
Also was infrage kommt und unter welchen Bedingungen
vielleicht aus der Aufgabenstellung heraus

0:12:02.540,0:12:07.730
noch irgendwie Ziffern vergeben werden dürfen oder nicht.
Also zum Beispiel, dass nicht verschiedene Buchstaben

0:12:07.730,0:12:13.360
die gleiche Ziffer haben dürfen. Das müssen wir
ausdrücken in dem Generierungsprädikat. Das war hier durch

0:12:13.360,0:12:17.950
die Permutation geschehen. In anderen Aufgaben mag das vielleicht
keine Forderung sein. Da muss das anders beschrieben werden.

0:12:17.950,0:12:24.310
Vielleicht nur mit member, statt mit permutieren. Dann
müssen im Test-Teil eben alle Bedingungen ausgedrückt werden.

0:12:24.310,0:12:29.660
Dann kann das mit Prolog gelöst werden. Und auf
ähnliche Art und Weise lassen sich natürlich

0:12:29.660,0:12:36.060
viele so arithmetische oder kombinatorische Probleme
prinzipiell lösen. Also auch Sudoku kann auf

0:12:36.060,0:12:40.790
ähnliche Weise letztlich in Prolog ausgedrückt werden. Da
dauert die Suche nur etwas länger, wahrscheinlich weil

0:12:40.790,0:12:45.330
Sudokus größer sind und sehr viel mehr Wahlen
zulassen, als jetzt einfach nur die Belegung

0:12:45.330,0:12:55.240
dieser acht Buchstaben. Aber das generelle Prinzip lässt sich
auf sehr viele solche kombinatorischen Probleme anwenden.
